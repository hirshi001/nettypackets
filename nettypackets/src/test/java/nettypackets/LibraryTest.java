/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package nettypackets;

import io.netty.bootstrap.Bootstrap;
import io.netty.bootstrap.ServerBootstrap;
import io.netty.channel.Channel;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelOption;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.DatagramChannel;
import io.netty.channel.socket.DatagramPacket;
import io.netty.channel.socket.SocketChannel;
import io.netty.channel.socket.nio.NioDatagramChannel;
import io.netty.channel.socket.nio.NioServerSocketChannel;
import io.netty.channel.socket.nio.NioSocketChannel;
import io.netty.util.AttributeKey;
import io.netty.util.concurrent.DefaultEventExecutor;
import io.netty.util.concurrent.EventExecutor;
import io.netty.util.concurrent.Future;
import logger.ConsoleColors;
import logger.DateStringFunction;
import logger.Logger;
import nettypackets.network.client.*;
import nettypackets.network.listeners.clientlistener.AbstractClientListener;
import nettypackets.network.listeners.serverlistener.AbstractServerListener;
import nettypackets.network.packethandlercontext.PacketHandlerContext;
import nettypackets.network.packethandlercontext.PacketType;
import nettypackets.network.server.IServer;
import nettypackets.network.server.Server;
import nettypackets.network.server.TCPServer;
import nettypackets.network.server.UDPServer;
import nettypackets.networkdata.DefaultNetworkData;
import nettypackets.networkdata.NetworkData;
import nettypackets.packet.Packet;
import nettypackets.packet.PacketHolder;
import nettypackets.packetdecoderencoder.PacketEncoderDecoder;
import nettypackets.packetdecoderencoder.SimplePacketEncoderDecoder;
import nettypackets.packetregistry.PacketRegistry;
import nettypackets.packetregistrycontainer.MultiPacketRegistryContainer;
import nettypackets.packetregistrycontainer.PacketRegistryContainer;
import nettypackets.restapi.DefaultRestAction;
import nettypackets.restapi.RestAction;
import nettypackets.util.defaultpackets.primitivepackets.StringPacket;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.Function;

public class LibraryTest {


    public static PacketEncoderDecoder encoderDecoder;



    @BeforeEach
    public void setUp() throws Exception {
        encoderDecoder = new SimplePacketEncoderDecoder();
        System.setOut(new Logger(System.out, System.err, new DateStringFunction(ConsoleColors.RED, "[","]")).debugShort(true).debug());

    }


    @Test
    public void RestActionTest() throws InterruptedException {
        RestAction<Packet> action = new DefaultRestAction<>((next, promise)->{
            next.submitTask(new TestPacket("sup dawgs"));
        });

        Future<String> futureAction = action
                .then(packet -> System.out.println("Packet received: " + packet))
                .map(packet -> ((TestPacket) packet).message).pauseFor(1000)
                .getRestFuture().addListener(future -> {
                    if(future.isSuccess()){
                        System.out.println("RestActionTest: " + future.getNow());
                    }
                }).perform();

        Thread.sleep(2000);

        assert futureAction.isSuccess();
    }


    @Test
    public void TCP_TEST() throws InterruptedException {

        AtomicBoolean flag1 = new AtomicBoolean(false);

        EventExecutor eventExecutor = new DefaultEventExecutor();

        PacketRegistryContainer serverPacketRegistryContainer = new MultiPacketRegistryContainer();
        NetworkData serverNetworkData = new DefaultNetworkData(encoderDecoder, serverPacketRegistryContainer);
        serverPacketRegistryContainer.getDefaultRegistry().registerDefaultPrimitivePackets();
        serverPacketRegistryContainer.getDefaultRegistry().register(new PacketHolder<>(TestPacket::new, TestPacket::serverHandle, TestPacket.class), 0);

        TCPServer server = new TCPServer(8080, serverNetworkData, eventExecutor);
        server.init();
        server.addListener(new AbstractServerListener<TCPServer>() {
            @Override
            public void tcpPacketWritten(Packet packet, PacketRegistry registry, ChannelHandlerContext context, TCPServer side) {
                super.tcpPacketWritten(packet, registry, context, side);
                System.out.println("Packet Written from server to client: " + packet);
            }
        });
        server.connect(new ServerBootstrap().
                group(new NioEventLoopGroup(), new NioEventLoopGroup()).
                channel(NioServerSocketChannel.class).
                option(ChannelOption.SO_BACKLOG, 128).
                childOption(ChannelOption.SO_KEEPALIVE, true)).syncUninterruptibly();
        Thread.sleep(100);
        assert server.isConnected();



        PacketRegistryContainer clientPacketRegistryContainer = new MultiPacketRegistryContainer();
        NetworkData clientNetworkData = new DefaultNetworkData(encoderDecoder, clientPacketRegistryContainer);

        clientPacketRegistryContainer.getDefaultRegistry().registerDefaultPrimitivePackets();
        clientPacketRegistryContainer.getDefaultRegistry().register(new PacketHolder<>(TestPacket::new, TestPacket::clientHandle, TestPacket.class), 0);

        TCPClient client = new TCPClient("localhost", 8080, clientNetworkData, eventExecutor);
        client.init();
        client.addListener(new AbstractClientListener<TCPClient>(){
            @Override
            public void tcpPacketReceived(PacketHandlerContext<?> context, TCPClient side) {
                super.tcpPacketReceived(context, side);
                System.out.println("Packet received on client");
            }
        });
        client.connect(new Bootstrap().
                group(new NioEventLoopGroup()).
                channel(NioSocketChannel.class).
                option(ChannelOption.SO_KEEPALIVE, true)).awaitUninterruptibly();
        Thread.sleep(100);
        assert client.isConnected();


        client.sendWithResponse(new TestPacket("sup dawgs"), clientPacketRegistryContainer.getDefaultRegistry(), 100)
                .map(context -> context.packet)
                .map(packet -> ((StringPacket) packet).value)
                .then(System.out::print).then((s)->{
                    flag1.set(true);
                }).perform().sync();

        Thread.sleep(1000);
        assert flag1.get();
    }



    @Test
    public void UDP_TEST() throws InterruptedException {
        AtomicBoolean flag1 = new AtomicBoolean(false);

        EventExecutor eventExecutor = new DefaultEventExecutor();

        PacketRegistryContainer serverPacketRegistryContainer = new MultiPacketRegistryContainer();
        NetworkData serverNetworkData = new DefaultNetworkData(encoderDecoder, serverPacketRegistryContainer);
        serverPacketRegistryContainer.getDefaultRegistry().registerDefaultPrimitivePackets();
        serverPacketRegistryContainer.getDefaultRegistry().register(new PacketHolder<>(TestPacket::new, TestPacket::serverHandle, TestPacket.class), 0);

        UDPServer server = new UDPServer(8080, serverNetworkData, eventExecutor);
        server.connect(new Bootstrap().
                group(new NioEventLoopGroup()).
                channel(NioDatagramChannel.class)).syncUninterruptibly();


        Thread.sleep(100);
        assert server.isConnected();


        PacketRegistryContainer clientPacketRegistryContainer = new MultiPacketRegistryContainer();
        NetworkData clientNetworkData = new DefaultNetworkData(encoderDecoder, clientPacketRegistryContainer);

        clientPacketRegistryContainer.getDefaultRegistry().registerDefaultPrimitivePackets();
        clientPacketRegistryContainer.getDefaultRegistry().register(new PacketHolder<>(TestPacket::new, TestPacket::clientHandle, TestPacket.class), 0);

        UDPClient client = new UDPClient("localhost", 8080, clientNetworkData, eventExecutor);



        client.connect(new Bootstrap().
                group(new NioEventLoopGroup()).
                channel(NioDatagramChannel.class)).awaitUninterruptibly();
        Thread.sleep(100);
        assert client.isConnected();


        int successCount = 0;
        for(int i=0;i<100;i++) {
            boolean success = client.sendWithResponse(new TestPacket("sup dawgs"), clientPacketRegistryContainer.getDefaultRegistry(), 100)
                    .map(context -> context.packet)
                    .map(packet -> ((StringPacket) packet).value)
                    .then((p)->{}).then((s) -> {
                        flag1.set(true);
                    }).pauseFor(0).perform().sync().isSuccess();
            if(success) successCount++;
        }
        System.out.println("Success count = " + successCount);

        System.out.println("Going to send");
        AtomicInteger counter = new AtomicInteger(0);
        for(int i=0;i<100;i++) {
        server.getConnections().forEach(connection -> {
            //System.out.println("HI--");
            server.sendWithResponse(new TestPacket("sup dawgs"), clientPacketRegistryContainer.getDefaultRegistry(), connection, 100).then((packetHandlerContext)->{
                    System.out.println(packetHandlerContext.packet);
                    counter.incrementAndGet();
                }).perform();
            });
        }
        Thread.sleep(1000);
        assert flag1.get();
        assert counter.get()==100;
    }

    @Test
    public void SERVER_CLIENT_TEST() throws InterruptedException {
        DefaultEventExecutor eventExecutor = new DefaultEventExecutor();
        Server server = new Server(8080, new DefaultNetworkData(encoderDecoder, new MultiPacketRegistryContainer()), eventExecutor);
        server.getNetworkData().getPacketRegistryContainer().getDefaultRegistry().registerDefaultPrimitivePackets();
        server.addListener(new AbstractServerListener<Server>(){
            @Override
            public void udpConnected(Server server) {
                super.udpConnected(server);
                System.out.println("UDP Connected");
            }

            @Override
            public void tcpPacketReceived(PacketHandlerContext<?> context, Server side) {
                super.tcpPacketReceived(context, side);
                if(context.packet instanceof StringPacket){
                    StringPacket packet = (StringPacket) context.packet;
                    side.sendTCP(new StringPacket("sup dawgs. Server received the message: " + packet.value).setResponsePacket(context.packet), context.packetRegistry, context.ctx.channel());
                }
            }
        });
        server.startTCPServer(new ServerBootstrap().
                group(new NioEventLoopGroup(), new NioEventLoopGroup()).
                channel(NioServerSocketChannel.class).
                option(ChannelOption.SO_BACKLOG, 128).
                childOption(ChannelOption.SO_KEEPALIVE, true)).awaitUninterruptibly();
        server.startUDPServer(new Bootstrap().
                group(new NioEventLoopGroup()).
                channel(NioDatagramChannel.class)).awaitUninterruptibly();

        Thread.sleep(100);

        assert server.isTCPConnected();
        assert server.isUDPConnected();
        assert server.isConnected();

        Client client = new Client("localhost", 8080, new DefaultNetworkData(encoderDecoder, new MultiPacketRegistryContainer()), eventExecutor);
        client.getNetworkData().getPacketRegistryContainer().getDefaultRegistry().registerDefaultPrimitivePackets();
        client.startTCPClient(new Bootstrap().
                group(new NioEventLoopGroup()).
                channel(NioSocketChannel.class)).awaitUninterruptibly();
        client.startUDPClient(new Bootstrap().
                group(new NioEventLoopGroup()).
                channel(NioDatagramChannel.class)).awaitUninterruptibly();

        Thread.sleep(100);

        assert client.isTCPConnected();
        assert client.isUDPConnected();
        assert client.isConnected();

        client.sendTCPWithResponse(new StringPacket("HI BITCH"), null, 1000)
                .map(packetHandlerContext -> packetHandlerContext.packet.toString())
                .then((string)->{
                    System.out.println("Message recieved from server is " + string);
                }).perform();
        Thread.sleep(1000);

    }


}
